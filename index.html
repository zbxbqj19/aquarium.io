<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>스마트 아쿠아리움 시뮬레이션</title>
  <meta name="description" content="온도·조도·산소·pH를 통합 제어하는 3D 스마트 아쿠아리움 시뮬레이션" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Pretendard:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg1: #0f172a; /* slate-900 */
      --bg2: #0b1220;
      --card: rgba(255,255,255,0.08);
      --card-strong: rgba(255,255,255,0.12);
      --stroke: rgba(255,255,255,0.14);
      --text: #e5e7eb; /* gray-200 */
      --muted: #94a3b8; /* slate-400 */
      --accent: #38bdf8; /* sky-400 */
      --accent-2: #a78bfa; /* violet-400 */
      --good: #34d399; /* emerald-400 */
      --warn: #fbbf24; /* amber-400 */
      --bad: #fb7185; /* rose-400 */
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius: 18px;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: 'Pretendard', ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji;
      color: var(--text);
      background: radial-gradient(1200px 800px at 80% -10%, #1f2937 0%, #0b1020 35%, var(--bg2) 100%),
                  linear-gradient(180deg, var(--bg1), var(--bg2));
      overflow: hidden;
    }
    header {
      position: fixed; inset: 16px 16px auto 16px; z-index: 30;
      display: flex; align-items: center; justify-content: space-between;
      padding: 12px 16px; border: 1px solid var(--stroke);
      border-radius: var(--radius); background: var(--card); backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
    }
    header .brand {
      display: flex; align-items: center; gap: 10px; font-weight: 700;
      letter-spacing: 0.2px;
    }
    header .brand .dot {
      width: 10px; height: 10px; border-radius: 6px;
      background: conic-gradient(from 0deg, var(--accent), var(--accent-2));
      box-shadow: 0 0 18px rgba(56,189,248,0.6);
    }
    header nav { display: flex; gap: 8px; }
    .btn {
      appearance: none; border: 1px solid var(--stroke); border-radius: 14px;
      padding: 8px 14px; background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
      color: var(--text); cursor: pointer; transition: 0.2s ease;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    .btn:hover { transform: translateY(-1px); border-color: rgba(255,255,255,0.26); }
    .btn.primary { border-color: rgba(56,189,248,0.45); background: linear-gradient(180deg, rgba(56,189,248,0.18), rgba(56,189,248,0.08)); }

    main { position: absolute; inset: 80px 16px 16px 16px; display: grid; grid-template-columns: 380px 1fr; gap: 16px; }
    @media (max-width: 1024px) { main { grid-template-columns: 1fr; grid-template-rows: 420px 1fr; } }

    .panel {
      border: 1px solid var(--stroke); border-radius: var(--radius);
      background: var(--card); backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
    }

    /* Controls */
    #controls { padding: 16px; display: grid; gap: 14px; overflow: auto; }
    .section { border: 1px solid var(--stroke); border-radius: 16px; padding: 14px; background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02)); }
    .section h3 { margin: 0 0 8px; font-size: 15px; font-weight: 700; color: white; }
    .row { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; margin: 10px 0; }
    .muted { color: var(--muted); font-size: 12px; }
    label { font-size: 13px; color: var(--text); }
    input[type="range"] { width: 100%; }
    .readout { font-variant-numeric: tabular-nums; padding: 2px 8px; border-radius: 10px; background: rgba(255,255,255,0.08); border: 1px solid var(--stroke); }
    .chip { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 999px; border: 1px solid var(--stroke); background: rgba(255,255,255,0.06); font-size: 12px; }
    .chip .dot { width: 6px; height: 6px; border-radius: 6px; background: var(--muted); box-shadow: 0 0 10px rgba(255,255,255,0.3); }
    .chip.on .dot { background: var(--good); }
    .chip.warn .dot { background: var(--warn); }
    .chip.bad .dot { background: var(--bad); }

    /* Canvas area */
    #viewport { position: relative; overflow: hidden; }
    #three { width: 100%; height: 100%; display: block; border-radius: var(--radius); }

    /* Status footer */
    #status { position: absolute; left: 16px; right: 16px; bottom: 16px; display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; }
    @media (max-width: 1024px) { #status { grid-template-columns: repeat(2, 1fr); } }
    .stat { padding: 10px 12px; border: 1px solid var(--stroke); background: var(--card-strong); border-radius: 14px; display: grid; gap: 6px; }
    .stat small { color: var(--muted); font-size: 11px; }
    .stat .value { font-size: 18px; font-weight: 700; }

    /* Toast */
    #toast { position: fixed; right: 20px; bottom: 24px; display: none; padding: 12px 14px; border-radius: 12px; background: #111827; border: 1px solid var(--stroke); box-shadow: var(--shadow); z-index: 50; }

    /* Switch */
    .switch { position: relative; display: inline-block; width: 44px; height: 24px; }
    .switch input { display: none; }
    .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255,255,255,0.2); border-radius: 999px; border: 1px solid var(--stroke); transition: .2s; }
    .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 2px; background-color: white; border-radius: 50%; transition: .2s; }
    input:checked + .slider { background: linear-gradient(90deg, var(--accent), var(--accent-2)); }
    input:checked + .slider:before { transform: translateX(20px); }

    a, a:visited { color: #c7d2fe; text-decoration: none; }
  </style>
</head>
<body>
  <header>
    <div class="brand"><span class="dot"></span> 스마트 아쿠아리움 시뮬레이션</div>
    <nav>
      <button class="btn" id="btnReset">리셋</button>
      <button class="btn primary" id="btnSave">설정 저장</button>
      <a class="btn" href="https://github.com/" target="_blank" rel="noreferrer">GitHub Pages 가이드</a>
    </nav>
  </header>

  <main>
    <aside id="controls" class="panel">
      <div class="section">
        <h3>시뮬레이션 제어</h3>
        <div class="row"><label>실행</label>
          <label class="switch"><input type="checkbox" id="runToggle" checked><span class="slider"></span></label>
        </div>
        <div class="row"><label>자동 모드 (센서 기반)</label>
          <label class="switch"><input type="checkbox" id="autoToggle" checked><span class="slider"></span></label>
        </div>
        <div class="muted">자동 모드에서는 날씨/환경에 따라 조명·히터·산소공급이 스스로 조절됩니다.</div>
      </div>

      <div class="section" id="tempSec">
        <h3>온도 & 히터</h3>
        <div class="row"><label>목표 온도 (<span id="targetTempLabel">26</span>°C)</label>
          <span class="readout" id="heaterState">대기</span>
        </div>
        <input type="range" id="targetTemp" min="20" max="30" value="26" step="0.5">
        <div class="muted">수온은 외기 및 히터 상태에 따라 변화합니다.</div>
      </div>

      <div class="section" id="lightSec">
        <h3>조도 & 날씨 연동</h3>
        <div class="row"><label>구름(태양 가림)</label><span class="readout" id="cloudLabel">20%</span></div>
        <input type="range" id="cloud" min="0" max="100" value="20">
        <div class="row"><label>LED 광량 (자동시 구름 ↑ → 밝기 ↑)</label><span class="readout" id="ledLabel">50%</span></div>
        <input type="range" id="led" min="0" max="100" value="50">
        <div class="muted">구름이 많을수록 태양광은 약해지며, 자동 모드에서는 LED가 더 밝아집니다.</div>
      </div>

      <div class="section" id="o2Sec">
        <h3>산소 공급</h3>
        <div class="row"><label>목표 O₂ 농도</label><span class="readout" id="o2TargetLabel">80%</span></div>
        <input type="range" id="o2Target" min="50" max="100" value="80">
        <div class="row"><span class="chip" id="oxygenatorChip"><span class="dot"></span>공급기</span><span class="readout" id="o2Read">-</span></div>
      </div>

      <div class="section" id="phSec">
        <h3>pH & 환수 주기</h3>
        <div class="row"><label>목표 pH</label><span class="readout" id="phTargetLabel">7.2</span></div>
        <input type="range" id="phTarget" min="6.0" max="8.5" step="0.1" value="7.2">
        <div class="row"><label>환수 주기</label>
          <select id="waterInterval">
            <option value="14">2주</option>
            <option value="28" selected>4주</option>
            <option value="56">8주</option>
            <option value="84">12주</option>
          </select>
        </div>
        <div class="muted">pH 편차가 커지거나 환수 예정일이 되면 알림이 뜹니다.</div>
      </div>

      <div class="section">
        <h3>서버/배포 팁</h3>
        <ul class="muted" style="margin:0 0 0 18px; padding:0; display:grid; gap:6px;">
          <li>이 파일 하나로도 GitHub Pages에서 동작합니다.</li>
          <li>추후 서버를 붙일 경우 센서 데이터를 WebSocket/REST로 바인딩하세요.</li>
          <li>로컬 설정은 브라우저 LocalStorage에 저장됩니다.</li>
        </ul>
      </div>
    </aside>

    <section id="viewport" class="panel">
      <canvas id="three"></canvas>
    </section>

    <section id="status">
      <div class="stat"><small>수온</small><div class="value" id="tempStat">-</div><small id="tempHint" class="muted">히터 상태: -</small></div>
      <div class="stat"><small>조도</small><div class="value" id="luxStat">-</div><small class="muted">태양/LED 조합</small></div>
      <div class="stat"><small>용존 산소</small><div class="value" id="o2Stat">-</div><small class="muted">공급기 상태 표시</small></div>
      <div class="stat"><small>pH</small><div class="value" id="phStat">-</div><small id="waterDue" class="muted">환수 D-</small></div>
    </section>
  </main>

  <div id="toast"></div>

  <!-- Three.js (module) -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    // ======= State =======
    const state = {
      running: true,
      auto: true,
      time: 0,
      // environment
      cloud: 0.2, // 0..1
      sunLux: 6000, // base outdoor lux approximation (reduced by cloud)
      led: 0.5, // 0..1
      // water
      temp: 25.0,
      targetTemp: 26.0,
      ambient: 22.0,
      heaterOn: false,
      o2: 0.75, // 0..1
      o2Target: 0.8,
      oxygenator: false,
      ph: 7.2,
      phTarget: 7.2,
      lastWaterChange: Date.now(),
      waterIntervalDays: 28,
    };

    // ======= UI Elements =======
    const $ = (sel)=>document.querySelector(sel);
    const threeCanvas = $('#three');

    const runToggle = $('#runToggle');
    const autoToggle = $('#autoToggle');
    const targetTemp = $('#targetTemp');
    const targetTempLabel = $('#targetTempLabel');
    const heaterState = $('#heaterState');
    const cloud = $('#cloud');
    const cloudLabel = $('#cloudLabel');
    const led = $('#led');
    const ledLabel = $('#ledLabel');
    const o2Target = $('#o2Target');
    const o2TargetLabel = $('#o2TargetLabel');
    const oxygenatorChip = $('#oxygenatorChip');
    const phTarget = $('#phTarget');
    const phTargetLabel = $('#phTargetLabel');
    const waterInterval = $('#waterInterval');

    const tempStat = $('#tempStat');
    const tempHint = $('#tempHint');
    const luxStat = $('#luxStat');
    const o2Stat = $('#o2Stat');
    const phStat = $('#phStat');
    const waterDue = $('#waterDue');

    const btnReset = $('#btnReset');
    const btnSave = $('#btnSave');
    const toast = $('#toast');

    // ======= Persistence =======
    const STORAGE_KEY = 'smart-aqua-config-v1';
    function saveConfig(){
      const conf = {
        targetTemp: state.targetTemp,
        cloud: state.cloud,
        led: state.led,
        o2Target: state.o2Target,
        phTarget: state.phTarget,
        waterIntervalDays: state.waterIntervalDays,
        lastWaterChange: state.lastWaterChange,
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(conf));
      showToast('설정을 저장했어요.');
    }
    function loadConfig(){
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return;
      try {
        const conf = JSON.parse(raw);
        Object.assign(state, conf);
        targetTemp.value = state.targetTemp;
        targetTempLabel.textContent = state.targetTemp.toFixed(1);
        cloud.value = Math.round(state.cloud*100); cloudLabel.textContent = Math.round(state.cloud*100)+'%';
        led.value = Math.round(state.led*100); ledLabel.textContent = Math.round(state.led*100)+'%';
        o2Target.value = Math.round(state.o2Target*100); o2TargetLabel.textContent = Math.round(state.o2Target*100)+'%';
        phTarget.value = state.phTarget.toFixed(1); phTargetLabel.textContent = state.phTarget.toFixed(1);
        waterInterval.value = String(state.waterIntervalDays);
      } catch(e){ console.warn(e); }
    }

    // ======= UI Events =======
    runToggle.addEventListener('change', e=> state.running = e.target.checked);
    autoToggle.addEventListener('change', e=> state.auto = e.target.checked);

    targetTemp.addEventListener('input', e=>{ state.targetTemp = parseFloat(e.target.value); targetTempLabel.textContent = state.targetTemp.toFixed(1); });

    cloud.addEventListener('input', e=>{ state.cloud = parseInt(e.target.value)/100; cloudLabel.textContent = e.target.value+'%'; });

    led.addEventListener('input', e=>{ state.led = parseInt(e.target.value)/100; ledLabel.textContent = e.target.value+'%'; });

    o2Target.addEventListener('input', e=>{ state.o2Target = parseInt(e.target.value)/100; o2TargetLabel.textContent = Math.round(state.o2Target*100)+'%'; });

    phTarget.addEventListener('input', e=>{ state.phTarget = parseFloat(e.target.value); phTargetLabel.textContent = state.phTarget.toFixed(1); });

    waterInterval.addEventListener('change', e=>{ state.waterIntervalDays = parseInt(e.target.value); updateWaterDueLabel(); });

    btnReset.addEventListener('click', ()=>{ localStorage.removeItem(STORAGE_KEY); location.reload(); });
    btnSave.addEventListener('click', saveConfig);

    function showToast(msg){
      toast.textContent = msg; toast.style.display = 'block';
      setTimeout(()=> toast.style.display = 'none', 2500);
    }

    // ======= 3D Scene =======
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0b1020, 0.035);

    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 100);
    camera.position.set(2.6, 1.8, 3.0);

    const renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, antialias: true, alpha: true });
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.05; controls.target.set(0,0.7,0);

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.35);
    scene.add(ambient);

    const sun = new THREE.DirectionalLight(0xfff6e0, 1.2);
    sun.position.set(-5, 6, 3);
    scene.add(sun);

    const ledLight = new THREE.PointLight(0x8ab4ff, 1.0, 10);
    ledLight.position.set(0, 1.8, 0);
    scene.add(ledLight);

    // Tank (glass)
    const glassMat = new THREE.MeshPhysicalMaterial({ color: 0x9ec5ff, metalness: 0, roughness: 0.2, transmission: 0.8, thickness: 0.02, transparent: true, opacity: 0.4 });
    const tankGeo = new THREE.BoxGeometry(2.0, 1.2, 1.0);
    const tank = new THREE.Mesh(tankGeo, glassMat);
    tank.position.y = 0.6;
    scene.add(tank);

    // Water
    const waterMat = new THREE.MeshPhysicalMaterial({ color: 0x2aa7ff, metalness: 0, roughness: 0.2, transmission: 0.95, thickness: 0.2, transparent: true, opacity: 0.8 });
    const waterGeo = new THREE.BoxGeometry(1.94, 1.0, 0.94);
    const water = new THREE.Mesh(waterGeo, waterMat);
    water.position.y = 0.5;
    scene.add(water);

    // Gravel
    const ground = new THREE.Mesh(new THREE.CylinderGeometry(1.0, 1.0, 0.02, 48), new THREE.MeshStandardMaterial({ color: 0x3f3f46, roughness: 0.8 }));
    ground.position.y = 0.02;
    scene.add(ground);

    // Heater
    const heater = new THREE.Mesh(new THREE.CapsuleGeometry(0.03, 0.4, 8, 16), new THREE.MeshStandardMaterial({ color: 0x444 }));
    heater.position.set(-0.85, 0.4, 0.0);
    scene.add(heater);

    // Bubble system (Points)
    const bubbleCountBase = 400;
    let bubbleGeo = new THREE.BufferGeometry();
    let positions = new Float32Array(bubbleCountBase*3);
    function resetBubbles(){
      for(let i=0;i<bubbleCountBase;i++){
        positions[i*3+0] = THREE.MathUtils.randFloatSpread(0.8);
        positions[i*3+1] = THREE.MathUtils.randFloat(0.05, 0.9);
        positions[i*3+2] = THREE.MathUtils.randFloatSpread(0.7);
      }
      bubbleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    }
    resetBubbles();
    const bubbleMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.01, transparent: true, opacity: 0.9 });
    const bubbles = new THREE.Points(bubbleGeo, bubbleMat);
    scene.add(bubbles);

    // Decorative fish (simple)
    function createFish(){
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.08, 22, 22), new THREE.MeshStandardMaterial({ color: 0xffc857, metalness: 0.1, roughness: 0.5 }));
      const tail = new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.12, 16), new THREE.MeshStandardMaterial({ color: 0xffa6a6 }));
      tail.rotation.z = Math.PI/2; tail.position.x = -0.1;
      const fish = new THREE.Group(); fish.add(body); fish.add(tail);
      fish.position.set(0.3, 0.6, 0);
      return fish;
    }
    const fish = createFish(); scene.add(fish);

    // Resize
    function onResize(){
      const rect = threeCanvas.getBoundingClientRect();
      renderer.setSize(rect.width, rect.height, false);
      camera.aspect = rect.width/rect.height; camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);
    setTimeout(onResize, 0);

    // ======= Simulation Logic =======
    function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }

    function updateEnvironment(dt){
      // Ambient temp varies with sun (more sun -> slightly warmer)
      state.ambient = 20 + (1-state.cloud)*4 + Math.sin(state.time*0.05)*0.8;

      // Sun lux decreases with cloud
      const sunLux = state.sunLux * (1 - state.cloud);

      // Auto: LED inversely follows cloud level
      if(state.auto){
        const targetLed = 0.25 + state.cloud*0.75; // 0.25~1.0
        state.led += (targetLed - state.led) * 0.5 * dt; // smooth
        led.value = Math.round(state.led*100); ledLabel.textContent = Math.round(state.led*100)+'%';
      }

      // Effective tank lux (scaled):
      const lux = sunLux*0.15 + state.led*800; // arbitrary scale for display
      luxStat.textContent = Math.round(lux) + ' lx (가상)';

      // Update three.js lights
      sun.intensity = 0.6 + (1-state.cloud)*0.8; // 0.6~1.4
      ledLight.intensity = 0.4 + state.led*1.6;  // 0.4~2.0
    }

    function updateWater(dt){
      // Temperature dynamics: move towards ambient or target if heater on
      const diff = state.targetTemp - state.temp;
      state.heaterOn = diff > 0.2; // hysteresis
      const heatPower = state.heaterOn ? 0.8 : 0.0; // heating rate
      const coolRate = 0.15 * (state.temp - state.ambient); // cooling proportional to delta
      state.temp += (heatPower*diff - coolRate) * dt;
      state.temp = clamp(state.temp, 15, 32);

      // Oxygen dynamics
      // Auto oxygenator based on target
      if(state.auto){ state.oxygenator = state.o2 < state.o2Target; }
      const o2In = state.oxygenator ? 0.35 : 0.05; // supply strength
      const o2Out = 0.12; // consumption & outgassing
      state.o2 += (o2In*(state.o2Target - state.o2) - o2Out*(state.o2 - 0.6)) * dt;
      state.o2 = clamp(state.o2, 0.5, 1.0);

      // pH drift: slowly away from target without water change
      const daysSince = (Date.now() - state.lastWaterChange)/(1000*60*60*24);
      const drift = Math.sin(state.time*0.02)*0.03 + daysSince*0.002; // accumulate drift
      state.ph += (state.phTarget + drift - state.ph) * 0.2 * dt;

      // Visual feedbacks
      heater.material.color.set(state.heaterOn ? 0xff6666 : 0x444444);
      const bubbleSpeed = state.oxygenator ? 0.9 : 0.35;
      // animate bubbles upward
      const pos = bubbles.geometry.attributes.position.array;
      for(let i=0;i<bubbleCountBase;i++){
        pos[i*3+1] += bubbleSpeed*dt*Math.random()*0.4;
        if(pos[i*3+1] > 0.95){ pos[i*3+1] = 0.05; pos[i*3+0] = THREE.MathUtils.randFloatSpread(0.8); pos[i*3+2] = THREE.MathUtils.randFloatSpread(0.7); }
      }
      bubbles.geometry.attributes.position.needsUpdate = true;

      // fish swim
      fish.position.x = Math.sin(state.time*0.6)*0.6;
      fish.position.y = 0.6 + Math.sin(state.time*1.2)*0.05;
      fish.rotation.y = Math.cos(state.time*0.6) > 0 ? 0 : Math.PI;

      // UI text updates
      tempStat.textContent = state.temp.toFixed(1) + '°C';
      tempHint.textContent = `히터 상태: ${state.heaterOn ? '가동' : '대기'} / 외기 ${state.ambient.toFixed(1)}°C`;
      o2Stat.textContent = Math.round(state.o2*100) + '%';
      $('#o2Read').textContent = `${Math.round(state.o2*100)}% (목표 ${Math.round(state.o2Target*100)}%)`;
      oxygenatorChip.classList.toggle('on', state.oxygenator);
      oxygenatorChip.classList.toggle('warn', state.o2 < 0.65);
      oxygenatorChip.classList.toggle('bad', state.o2 < 0.58);
      phStat.textContent = state.ph.toFixed(2);

      // pH alert
      if(Math.abs(state.ph - state.phTarget) > 0.5){
        showToast('pH 편차가 큽니다. 환수 또는 조치를 권장합니다.');
      }
    }

    function updateWaterDueLabel(){
      const daysSince = Math.floor((Date.now() - state.lastWaterChange)/(1000*60*60*24));
      const remain = Math.max(0, state.waterIntervalDays - daysSince);
      waterDue.textContent = `환수 D-${remain} (주기 ${state.waterIntervalDays}일)`;
      if(remain === 0){ showToast('환수 예정일이에요! 물갈이를 해주세요.'); }
    }

    // Manual water change (double-click on pH section)
    $('#phSec').addEventListener('dblclick', ()=>{
      state.lastWaterChange = Date.now();
      state.ph = state.phTarget; // reset drift
      updateWaterDueLabel();
      showToast('환수를 수행했어요. pH가 안정되었습니다.');
    });

    // ======= Loop =======
    let last = performance.now();
    function tick(now){
      const dt = Math.min(0.1, (now - last)/1000); // cap dt for stability
      last = now; if(!state.running){ requestAnimationFrame(tick); return; }
      state.time += dt;
      updateEnvironment(dt);
      updateWater(dt);
      controls.update();
      renderer.render(scene, camera);
      updateWaterDueLabel();
      requestAnimationFrame(tick);
    }

    // Init
    loadConfig();
    onResize();
    requestAnimationFrame(tick);

  </script>
</body>
</html>
